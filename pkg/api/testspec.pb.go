// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: pkg/api/testspec.proto

package api

import (
	fmt "fmt"
	io "io"
	math "math"
	math_bits "math/bits"

	proto "github.com/gogo/protobuf/proto"
	types "github.com/gogo/protobuf/types"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// If the jobs in this spec. should be cancelled.
type TestSpec_Cancel int32

const (
	TestSpec_NO     TestSpec_Cancel = 0
	TestSpec_BY_ID  TestSpec_Cancel = 1
	TestSpec_BY_SET TestSpec_Cancel = 2
	TestSpec_BY_IDS TestSpec_Cancel = 3
)

var TestSpec_Cancel_name = map[int32]string{
	0: "NO",
	1: "BY_ID",
	2: "BY_SET",
	3: "BY_IDS",
}

var TestSpec_Cancel_value = map[string]int32{
	"NO":     0,
	"BY_ID":  1,
	"BY_SET": 2,
	"BY_IDS": 3,
}

func (x TestSpec_Cancel) String() string {
	return proto.EnumName(TestSpec_Cancel_name, int32(x))
}

func (TestSpec_Cancel) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_38d601305b414287, []int{0, 0}
}

// If the jobs in this spec. should be preempted.
type TestSpec_Preempt int32

const (
	TestSpec_PREEMPT_NO     TestSpec_Preempt = 0
	TestSpec_PREEMPT_BY_ID  TestSpec_Preempt = 1
	TestSpec_PREEMPT_BY_IDS TestSpec_Preempt = 2
)

var TestSpec_Preempt_name = map[int32]string{
	0: "PREEMPT_NO",
	1: "PREEMPT_BY_ID",
	2: "PREEMPT_BY_IDS",
}

var TestSpec_Preempt_value = map[string]int32{
	"PREEMPT_NO":     0,
	"PREEMPT_BY_ID":  1,
	"PREEMPT_BY_IDS": 2,
}

func (x TestSpec_Preempt) String() string {
	return proto.EnumName(TestSpec_Preempt_name, int32(x))
}

func (TestSpec_Preempt) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_38d601305b414287, []int{0, 1}
}

// Defines a test case for the Armada test suite.
// Defined as a proto message to enable unmarshalling oneof fields.
type TestSpec struct {
	// Jobs to submit.
	// The n jobs herein are copied BatchSize times to produce n*BatchSize jobs.
	// A batch of n*BatchSize such jobs are submitted in each API call.
	// NumBatches such batches are submitted in total.
	Jobs []*JobSubmitRequestItem `protobuf:"bytes,1,rep,name=jobs,proto3" json:"jobs,omitempty"`
	// Events expected in response to submitting each job.
	ExpectedEvents []*EventMessage `protobuf:"bytes,2,rep,name=expected_events,json=expectedEvents,proto3" json:"expectedEvents,omitempty"`
	// Queue to submit jobs to.
	Queue string `protobuf:"bytes,3,opt,name=queue,proto3" json:"queue,omitempty"`
	// Job set to submit jobs to.
	JobSetId string `protobuf:"bytes,4,opt,name=job_set_id,json=jobSetId,proto3" json:"jobSetId,omitempty"`
	// Number of batches of jobs to submit.
	// If 0, will submit forever.
	NumBatches uint32 `protobuf:"varint,5,opt,name=num_batches,json=numBatches,proto3" json:"numBatches,omitempty"`
	// Number of copies of the provided jobs to submit per batch.
	BatchSize uint32 `protobuf:"varint,6,opt,name=batch_size,json=batchSize,proto3" json:"batchSize,omitempty"`
	// Time between batches.
	// If 0, jobs are submitted as quickly as possible.
	Interval *types.Duration `protobuf:"bytes,7,opt,name=interval,proto3" json:"interval,omitempty"`
	// Number of seconds to wait for jobs to finish.
	Timeout *types.Duration `protobuf:"bytes,8,opt,name=timeout,proto3" json:"timeout,omitempty"`
	Cancel  TestSpec_Cancel `protobuf:"varint,9,opt,name=cancel,proto3,enum=api.TestSpec_Cancel" json:"cancel,omitempty"`
	// Test name. Defaults to the filename if not provided.
	Name string `protobuf:"bytes,10,opt,name=name,proto3" json:"name,omitempty"`
	// Randomize clientId if not provided
	RandomClientId bool `protobuf:"varint,11,opt,name=random_client_id,json=randomClientId,proto3" json:"randomClientId,omitempty"`
	// Toggle should testsuite scrape Armada Job (pod) logs
	GetLogs bool `protobuf:"varint,12,opt,name=get_logs,json=getLogs,proto3" json:"getLogs,omitempty"`
	// Value of the environment label set on exported Prometheus metrics.
	Environment string `protobuf:"bytes,13,opt,name=environment,proto3" json:"environment,omitempty"`
	// Value of the target label set on exported Prometheus metrics.
	Target  string           `protobuf:"bytes,14,opt,name=target,proto3" json:"target,omitempty"`
	Preempt TestSpec_Preempt `protobuf:"varint,15,opt,name=preempt,proto3,enum=api.TestSpec_Preempt" json:"preempt,omitempty"`
	// Reason for preemption. Used when preempt is set.
	PreemptReason string `protobuf:"bytes,16,opt,name=preempt_reason,json=preemptReason,proto3" json:"preemptReason,omitempty"`
}

func (m *TestSpec) Reset()         { *m = TestSpec{} }
func (m *TestSpec) String() string { return proto.CompactTextString(m) }
func (*TestSpec) ProtoMessage()    {}
func (*TestSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_38d601305b414287, []int{0}
}
func (m *TestSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TestSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TestSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TestSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TestSpec.Merge(m, src)
}
func (m *TestSpec) XXX_Size() int {
	return m.Size()
}
func (m *TestSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_TestSpec.DiscardUnknown(m)
}

var xxx_messageInfo_TestSpec proto.InternalMessageInfo

func (m *TestSpec) GetJobs() []*JobSubmitRequestItem {
	if m != nil {
		return m.Jobs
	}
	return nil
}

func (m *TestSpec) GetExpectedEvents() []*EventMessage {
	if m != nil {
		return m.ExpectedEvents
	}
	return nil
}

func (m *TestSpec) GetQueue() string {
	if m != nil {
		return m.Queue
	}
	return ""
}

func (m *TestSpec) GetJobSetId() string {
	if m != nil {
		return m.JobSetId
	}
	return ""
}

func (m *TestSpec) GetNumBatches() uint32 {
	if m != nil {
		return m.NumBatches
	}
	return 0
}

func (m *TestSpec) GetBatchSize() uint32 {
	if m != nil {
		return m.BatchSize
	}
	return 0
}

func (m *TestSpec) GetInterval() *types.Duration {
	if m != nil {
		return m.Interval
	}
	return nil
}

func (m *TestSpec) GetTimeout() *types.Duration {
	if m != nil {
		return m.Timeout
	}
	return nil
}

func (m *TestSpec) GetCancel() TestSpec_Cancel {
	if m != nil {
		return m.Cancel
	}
	return TestSpec_NO
}

func (m *TestSpec) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TestSpec) GetRandomClientId() bool {
	if m != nil {
		return m.RandomClientId
	}
	return false
}

func (m *TestSpec) GetGetLogs() bool {
	if m != nil {
		return m.GetLogs
	}
	return false
}

func (m *TestSpec) GetEnvironment() string {
	if m != nil {
		return m.Environment
	}
	return ""
}

func (m *TestSpec) GetTarget() string {
	if m != nil {
		return m.Target
	}
	return ""
}

func (m *TestSpec) GetPreempt() TestSpec_Preempt {
	if m != nil {
		return m.Preempt
	}
	return TestSpec_PREEMPT_NO
}

func (m *TestSpec) GetPreemptReason() string {
	if m != nil {
		return m.PreemptReason
	}
	return ""
}

func init() {
	proto.RegisterEnum("api.TestSpec_Cancel", TestSpec_Cancel_name, TestSpec_Cancel_value)
	proto.RegisterEnum("api.TestSpec_Preempt", TestSpec_Preempt_name, TestSpec_Preempt_value)
	proto.RegisterType((*TestSpec)(nil), "api.TestSpec")
}

func init() { proto.RegisterFile("pkg/api/testspec.proto", fileDescriptor_38d601305b414287) }

var fileDescriptor_38d601305b414287 = []byte{
	// 730 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x94, 0xcf, 0x6e, 0xeb, 0x44,
	0x14, 0xc6, 0xe3, 0xa4, 0xcd, 0x9f, 0x13, 0xe2, 0xba, 0xd3, 0xf4, 0xde, 0xb9, 0x05, 0xc5, 0x51,
	0x17, 0x10, 0xa4, 0xca, 0x41, 0x2d, 0x42, 0x42, 0x6c, 0xa8, 0xdb, 0x54, 0x4a, 0x45, 0x21, 0x4a,
	0xba, 0x68, 0xd9, 0x58, 0xb6, 0x73, 0x70, 0x1d, 0x62, 0x8f, 0x6b, 0x8f, 0x2b, 0xe8, 0x53, 0xf0,
	0x1c, 0x3c, 0x09, 0xcb, 0x2e, 0x59, 0x59, 0xa8, 0xdd, 0xf9, 0x29, 0x50, 0xc6, 0x36, 0x4c, 0x56,
	0x77, 0x97, 0xf9, 0x7d, 0xdf, 0x77, 0x3c, 0x73, 0xce, 0x51, 0xe0, 0x5d, 0xf4, 0xab, 0x37, 0xb6,
	0x23, 0x7f, 0xcc, 0x31, 0xe1, 0x49, 0x84, 0xae, 0x11, 0xc5, 0x8c, 0x33, 0xd2, 0xb0, 0x23, 0xff,
	0x68, 0xe0, 0x31, 0xe6, 0xad, 0x71, 0x2c, 0x90, 0x93, 0xfe, 0x32, 0x5e, 0xa6, 0xb1, 0xcd, 0x7d,
	0x16, 0x16, 0xa6, 0xa3, 0x7e, 0x15, 0x4e, 0x52, 0x27, 0xf0, 0x79, 0x49, 0x0f, 0x2a, 0x8a, 0x4f,
	0x18, 0x96, 0xf0, 0x38, 0x6f, 0x43, 0xfb, 0x16, 0x13, 0xbe, 0x88, 0xd0, 0x25, 0xe7, 0xb0, 0xb3,
	0x62, 0x4e, 0x42, 0x95, 0x61, 0x63, 0xd4, 0x3d, 0xfd, 0x60, 0xd8, 0x91, 0x6f, 0x5c, 0x33, 0x67,
	0x21, 0xaa, 0xcc, 0xf1, 0x31, 0xc5, 0x84, 0x4f, 0x39, 0x06, 0x26, 0xc9, 0x33, 0x5d, 0xdd, 0x58,
	0x4f, 0x58, 0xe0, 0x73, 0x0c, 0x22, 0xfe, 0xfb, 0x5c, 0x44, 0xc9, 0x1d, 0xec, 0xe1, 0x6f, 0x11,
	0xba, 0x1c, 0x97, 0x96, 0xf8, 0x4e, 0x42, 0xeb, 0xa2, 0xda, 0xbe, 0xa8, 0x36, 0xd9, 0xa0, 0x1b,
	0x4c, 0x12, 0xdb, 0x43, 0xf3, 0xb3, 0x3c, 0xd3, 0x69, 0xe5, 0x16, 0x8a, 0x5c, 0x4f, 0xdd, 0x56,
	0xc8, 0x97, 0xb0, 0xfb, 0x98, 0x62, 0x8a, 0xb4, 0x31, 0x54, 0x46, 0x1d, 0xf3, 0x20, 0xcf, 0xf4,
	0x3d, 0x01, 0xa4, 0x4c, 0xe1, 0x20, 0x5f, 0x03, 0xac, 0x98, 0x63, 0x25, 0xc8, 0x2d, 0x7f, 0x49,
	0x77, 0x84, 0xff, 0x5d, 0x9e, 0xe9, 0x64, 0xc5, 0x9c, 0x05, 0xf2, 0xe9, 0x52, 0x8a, 0xb4, 0x2b,
	0x46, 0xbe, 0x85, 0x6e, 0x98, 0x06, 0x96, 0x63, 0x73, 0xf7, 0x01, 0x13, 0xba, 0x3b, 0x54, 0x46,
	0x3d, 0x93, 0xe6, 0x99, 0xde, 0x0f, 0xd3, 0xc0, 0x2c, 0xa8, 0x14, 0x84, 0xff, 0x29, 0xf9, 0x06,
	0x40, 0xc4, 0xac, 0xc4, 0x7f, 0x46, 0xda, 0x14, 0xc9, 0xf7, 0x79, 0xa6, 0x1f, 0x08, 0xba, 0xf0,
	0x9f, 0xe5, 0x4b, 0x76, 0xfe, 0x83, 0xe4, 0x06, 0xda, 0x7e, 0xc8, 0x31, 0x7e, 0xb2, 0xd7, 0xb4,
	0x35, 0x54, 0x44, 0xd3, 0x8b, 0xd9, 0x1a, 0xd5, 0x6c, 0x8d, 0xcb, 0x72, 0xb6, 0xc5, 0x0b, 0x2a,
	0xbb, 0xfc, 0x82, 0x8a, 0x91, 0x6b, 0x68, 0x71, 0x3f, 0x40, 0x96, 0x72, 0xda, 0xfe, 0x58, 0xb5,
	0xc3, 0x3c, 0xd3, 0xf7, 0x4b, 0xb7, 0x54, 0xac, 0x2a, 0x40, 0x4c, 0x68, 0xba, 0x76, 0xe8, 0xe2,
	0x9a, 0x76, 0x86, 0xca, 0x48, 0x3d, 0xed, 0x8b, 0xf9, 0x55, 0xab, 0x62, 0x5c, 0x08, 0xcd, 0xec,
	0xe7, 0x99, 0xae, 0x15, 0x3e, 0xa9, 0x48, 0x99, 0x24, 0x9f, 0xc3, 0x4e, 0x68, 0x07, 0x48, 0x41,
	0x4c, 0x40, 0x2c, 0xcd, 0xe6, 0x2c, 0x2f, 0xcd, 0xe6, 0x4c, 0xae, 0x40, 0x8b, 0xed, 0x70, 0xc9,
	0x02, 0xcb, 0x5d, 0xfb, 0x18, 0x8a, 0xa9, 0x75, 0x87, 0xca, 0xa8, 0x5d, 0xac, 0x48, 0xa1, 0x5d,
	0x08, 0x69, 0x6b, 0x76, 0xea, 0xb6, 0x42, 0xbe, 0x82, 0xb6, 0x87, 0xdc, 0x5a, 0x33, 0x2f, 0xa1,
	0x9f, 0x88, 0xbc, 0x78, 0xa5, 0x87, 0xfc, 0x07, 0xe6, 0xc9, 0xb3, 0x6b, 0x95, 0x88, 0x7c, 0x07,
	0x5d, 0x0c, 0x9f, 0xfc, 0x98, 0x85, 0x01, 0x86, 0x9c, 0xf6, 0xc4, 0x45, 0x3f, 0xe4, 0x99, 0x7e,
	0x28, 0x61, 0x29, 0x28, 0xbb, 0xc9, 0x09, 0x34, 0xb9, 0x1d, 0x7b, 0xc8, 0xa9, 0x2a, 0x72, 0xa2,
	0x19, 0x05, 0x91, 0x9b, 0x51, 0x10, 0x72, 0x05, 0xad, 0x28, 0xc6, 0x0d, 0xa3, 0x7b, 0xa2, 0xa3,
	0x87, 0xdb, 0x1d, 0x9d, 0x15, 0x62, 0x71, 0xe5, 0xd2, 0x29, 0x5f, 0xb9, 0x44, 0xc4, 0x04, 0xb5,
	0xfc, 0x69, 0xc5, 0x68, 0x27, 0x2c, 0xa4, 0x9a, 0xf8, 0xfa, 0xa7, 0x79, 0xa6, 0xbf, 0x2f, 0x95,
	0xb9, 0x10, 0xa4, 0x74, 0x6f, 0x4b, 0x38, 0x3e, 0x83, 0x66, 0x31, 0x40, 0xd2, 0x84, 0xfa, 0x8f,
	0x3f, 0x69, 0x35, 0xd2, 0x81, 0x5d, 0xf3, 0xde, 0x9a, 0x5e, 0x6a, 0x0a, 0x01, 0x68, 0x9a, 0xf7,
	0xd6, 0x62, 0x72, 0xab, 0xd5, 0xcb, 0xdf, 0xd3, 0xcb, 0x85, 0xd6, 0x38, 0xfe, 0x1e, 0x5a, 0xe5,
	0x1d, 0x89, 0x0a, 0x30, 0x9b, 0x4f, 0x26, 0x37, 0xb3, 0x5b, 0x4b, 0xa4, 0xf7, 0xa1, 0x57, 0x9d,
	0xab, 0x2a, 0x04, 0xd4, 0x2d, 0xb4, 0xd0, 0xea, 0xe6, 0xdd, 0x5f, 0xaf, 0x03, 0xe5, 0xe5, 0x75,
	0xa0, 0xfc, 0xf3, 0x3a, 0x50, 0xfe, 0x78, 0x1b, 0xd4, 0x5e, 0xde, 0x06, 0xb5, 0xbf, 0xdf, 0x06,
	0xb5, 0x9f, 0xbf, 0xf0, 0x7c, 0xfe, 0x90, 0x3a, 0x86, 0xcb, 0x82, 0xb1, 0x1d, 0x07, 0xf6, 0xd2,
	0x8e, 0x62, 0xb6, 0x42, 0x97, 0x97, 0xa7, 0x71, 0xf9, 0xdf, 0xf5, 0x67, 0xbd, 0x7f, 0x2e, 0xc0,
	0xac, 0x90, 0x8d, 0x29, 0x33, 0xce, 0x23, 0xdf, 0x69, 0x8a, 0x05, 0x3f, 0xfb, 0x37, 0x00, 0x00,
	0xff, 0xff, 0x9a, 0x18, 0x61, 0xab, 0x37, 0x05, 0x00, 0x00,
}

func (m *TestSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TestSpec) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TestSpec) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.PreemptReason) > 0 {
		i -= len(m.PreemptReason)
		copy(dAtA[i:], m.PreemptReason)
		i = encodeVarintTestspec(dAtA, i, uint64(len(m.PreemptReason)))
		i--
		dAtA[i] = 0x1
		i--
		dAtA[i] = 0x82
	}
	if m.Preempt != 0 {
		i = encodeVarintTestspec(dAtA, i, uint64(m.Preempt))
		i--
		dAtA[i] = 0x78
	}
	if len(m.Target) > 0 {
		i -= len(m.Target)
		copy(dAtA[i:], m.Target)
		i = encodeVarintTestspec(dAtA, i, uint64(len(m.Target)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.Environment) > 0 {
		i -= len(m.Environment)
		copy(dAtA[i:], m.Environment)
		i = encodeVarintTestspec(dAtA, i, uint64(len(m.Environment)))
		i--
		dAtA[i] = 0x6a
	}
	if m.GetLogs {
		i--
		if m.GetLogs {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x60
	}
	if m.RandomClientId {
		i--
		if m.RandomClientId {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i--
		dAtA[i] = 0x58
	}
	if len(m.Name) > 0 {
		i -= len(m.Name)
		copy(dAtA[i:], m.Name)
		i = encodeVarintTestspec(dAtA, i, uint64(len(m.Name)))
		i--
		dAtA[i] = 0x52
	}
	if m.Cancel != 0 {
		i = encodeVarintTestspec(dAtA, i, uint64(m.Cancel))
		i--
		dAtA[i] = 0x48
	}
	if m.Timeout != nil {
		{
			size, err := m.Timeout.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTestspec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x42
	}
	if m.Interval != nil {
		{
			size, err := m.Interval.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintTestspec(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x3a
	}
	if m.BatchSize != 0 {
		i = encodeVarintTestspec(dAtA, i, uint64(m.BatchSize))
		i--
		dAtA[i] = 0x30
	}
	if m.NumBatches != 0 {
		i = encodeVarintTestspec(dAtA, i, uint64(m.NumBatches))
		i--
		dAtA[i] = 0x28
	}
	if len(m.JobSetId) > 0 {
		i -= len(m.JobSetId)
		copy(dAtA[i:], m.JobSetId)
		i = encodeVarintTestspec(dAtA, i, uint64(len(m.JobSetId)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.Queue) > 0 {
		i -= len(m.Queue)
		copy(dAtA[i:], m.Queue)
		i = encodeVarintTestspec(dAtA, i, uint64(len(m.Queue)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.ExpectedEvents) > 0 {
		for iNdEx := len(m.ExpectedEvents) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.ExpectedEvents[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTestspec(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0x12
		}
	}
	if len(m.Jobs) > 0 {
		for iNdEx := len(m.Jobs) - 1; iNdEx >= 0; iNdEx-- {
			{
				size, err := m.Jobs[iNdEx].MarshalToSizedBuffer(dAtA[:i])
				if err != nil {
					return 0, err
				}
				i -= size
				i = encodeVarintTestspec(dAtA, i, uint64(size))
			}
			i--
			dAtA[i] = 0xa
		}
	}
	return len(dAtA) - i, nil
}

func encodeVarintTestspec(dAtA []byte, offset int, v uint64) int {
	offset -= sovTestspec(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *TestSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Jobs) > 0 {
		for _, e := range m.Jobs {
			l = e.Size()
			n += 1 + l + sovTestspec(uint64(l))
		}
	}
	if len(m.ExpectedEvents) > 0 {
		for _, e := range m.ExpectedEvents {
			l = e.Size()
			n += 1 + l + sovTestspec(uint64(l))
		}
	}
	l = len(m.Queue)
	if l > 0 {
		n += 1 + l + sovTestspec(uint64(l))
	}
	l = len(m.JobSetId)
	if l > 0 {
		n += 1 + l + sovTestspec(uint64(l))
	}
	if m.NumBatches != 0 {
		n += 1 + sovTestspec(uint64(m.NumBatches))
	}
	if m.BatchSize != 0 {
		n += 1 + sovTestspec(uint64(m.BatchSize))
	}
	if m.Interval != nil {
		l = m.Interval.Size()
		n += 1 + l + sovTestspec(uint64(l))
	}
	if m.Timeout != nil {
		l = m.Timeout.Size()
		n += 1 + l + sovTestspec(uint64(l))
	}
	if m.Cancel != 0 {
		n += 1 + sovTestspec(uint64(m.Cancel))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovTestspec(uint64(l))
	}
	if m.RandomClientId {
		n += 2
	}
	if m.GetLogs {
		n += 2
	}
	l = len(m.Environment)
	if l > 0 {
		n += 1 + l + sovTestspec(uint64(l))
	}
	l = len(m.Target)
	if l > 0 {
		n += 1 + l + sovTestspec(uint64(l))
	}
	if m.Preempt != 0 {
		n += 1 + sovTestspec(uint64(m.Preempt))
	}
	l = len(m.PreemptReason)
	if l > 0 {
		n += 2 + l + sovTestspec(uint64(l))
	}
	return n
}

func sovTestspec(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozTestspec(x uint64) (n int) {
	return sovTestspec(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *TestSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowTestspec
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TestSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TestSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Jobs", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestspec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestspec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestspec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Jobs = append(m.Jobs, &JobSubmitRequestItem{})
			if err := m.Jobs[len(m.Jobs)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpectedEvents", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestspec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestspec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestspec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExpectedEvents = append(m.ExpectedEvents, &EventMessage{})
			if err := m.ExpectedEvents[len(m.ExpectedEvents)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Queue", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestspec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestspec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestspec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Queue = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field JobSetId", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestspec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestspec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestspec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.JobSetId = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NumBatches", wireType)
			}
			m.NumBatches = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestspec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.NumBatches |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BatchSize", wireType)
			}
			m.BatchSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestspec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.BatchSize |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Interval", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestspec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestspec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestspec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Interval == nil {
				m.Interval = &types.Duration{}
			}
			if err := m.Interval.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Timeout", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestspec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthTestspec
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthTestspec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Timeout == nil {
				m.Timeout = &types.Duration{}
			}
			if err := m.Timeout.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cancel", wireType)
			}
			m.Cancel = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestspec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Cancel |= TestSpec_Cancel(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestspec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestspec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestspec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field RandomClientId", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestspec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.RandomClientId = bool(v != 0)
		case 12:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field GetLogs", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestspec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.GetLogs = bool(v != 0)
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Environment", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestspec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestspec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestspec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Environment = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestspec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestspec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestspec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Target = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 15:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Preempt", wireType)
			}
			m.Preempt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestspec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Preempt |= TestSpec_Preempt(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PreemptReason", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowTestspec
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthTestspec
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthTestspec
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PreemptReason = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipTestspec(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthTestspec
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipTestspec(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowTestspec
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTestspec
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowTestspec
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthTestspec
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupTestspec
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthTestspec
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthTestspec        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowTestspec          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupTestspec = fmt.Errorf("proto: unexpected end of group")
)
